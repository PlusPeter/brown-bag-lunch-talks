import { LiveCode } from 'mdx-deck-live-code'
import Flava from './images/flava.png'
import Questions from './images/questions.gif'
import { Definitions, Def, Term, Code, PaddedParagraph as PP } from './styles'
import { future } from '@mdx-deck/themes'

export const theme = {...future}

export const liveCodePreviewProps = {
  style: {
    textAlign: 'left',
    padding: '0.5em',
    color: 'black'
  }
}

## React
##### What is it and how does it work?

<small>
A presentation by Ramses ‚ú® & Brekk üçõ
</small>

---
<Split>

![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/React-icon.svg/512px-React-icon.svg.png)

<Definitions>
<Term>React</Term>
<Def>a framework created by Facebook which is designed to make declarative and efficient data-driven (unidirectional) UIs.</Def>
</Definitions>


</Split>

---

<SplitRight>

<img src={Flava} />

## What's with all the hype?

</SplitRight>

---
## HTML

<Code>

```
<p>In a standard <a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a> &amp; CSS page, you'd use HTML markup to organize / structure the page.</p>
<p>On page load, HTML is parsed by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">Document Object Model</a> and it then represents the structure of the page in memory.</p>
```

</Code>

---
## React

_What's good about it?_

1. Virtual DOM
2. Unidirectional flow
3. Server-Side Rendering
4. JSX - optional but wonderful

<Notes>
Virtual DOM, it's like the DOM, but virtual
Unidirectional flow
JSX - the last templating language you should have to learn
</Notes>

---

## Virtual DOM

* Reconciliation üëØ‚Äç‚ôÇÔ∏è
* Better than native ü§ì
* Fibers üß∂


<Notes>
In a React-rendered page, one of the chief differences is that React uses a Virtual DOM which is much more efficient at managing the difference between the last render and the next render. This abstraction allows us to declare the state of the application, and React manages the DOM to make sure it matches that state. Additionally, React's Virtual DOM has an underlying concept called "Fibers" (think memory-threads) which allow it to make more judicious updates of the application and render it more efficiently than raw HTML.
</Notes>

---

## Unidirectional Data-Flow

* A single source of truth 1Ô∏è‚É£
* Elements are immutable once drawn üöØ
* Events allow for signaling a re-render üìû
* No circular hell like in Angular / Vue üëø
* This lends itself to composition üéº

<Notes>
If you've worked with other JavaScript frameworks, you may be familiar with two-way binding &mdash; a circular hell where property and event binding is used to pass data from parent to child and vice-versa. This means that there are multiple sources of truth.
React does not allow for child-to-parent data transfer; instead it enforces a uni-directional "one source of truth" approach where the model updates the UI exclusively. When changes are needed, child components can pass events. This then tells the efficient Virtual DOM reconciliation to re-render only the parts of the application which have changed. In this way, React elements are immutable.
This process allows for much more straightforward debugging and reasoning about the application.
</Notes>

---

## Isomorphic & More

* Rendering in the browser ‚úî
* Rendering on the server ‚úî
* Rendering on mobile devices (React Native) ‚úî
* Views for CLI tools (Ink) ‚úî
* Views for Compositing video (Remotion) ‚úî

---

<LiveCode
  title="Why use JSX?"
  code={`() => {
    return (
      <article>
        <h1>Title</h1>
        <small>Author</small>
        <p>Summary</p>
      </article>
    )
  }`} 
  size="small"
  previewProps={liveCodePreviewProps} 
/>

<Notes>
React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.
</Notes>

---

<LiveCode
  title="Component: Composition, Class vs Functional"
  code={`() => {
    return (<div />)
  }`} 
  previewProps={liveCodePreviewProps} 
/>

---

<LiveCode
  title="State and Props"
  code={`() => {
    return (<div />)
  }`} 
  previewProps={liveCodePreviewProps} 
/>

---

## Downsides / Cons of React

* Conflation of concerns (HTML / CSS / JS) should be separate?
* TIMTOWTDI - "there's more than one way to do it"
* SEO
* Different approaches within various eras of React
  - "Class" Components
  - State management
  - Stateless Functional Components
  - Hooks

<Notes>
SEO
React requires Javascript to show the content on the page. The problem is that the Google crawl bot, that scans all the pages on the internet, 'isn‚Äôt as good as fast compiling a page with javascript compared with a page that consists of regular HTML-code'.
</Notes>

---

## Questions

<img src={Questions} />
